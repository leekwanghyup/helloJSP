# 커맨드 객체 값 검증과 에러메서지

<br>

## Validator와 Erros/BiningResult를 이용한 객체 검증

<br>

### 메세지 리소스 설정
> root-conext.xml
```xml
<!-- 빈의 아이디를 반드시 messageResource로 지정해야한다. -->
<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
	<property name="basenames">
		<list>
			<value>message.message</value>
		</list>
	</property>
	<property name="defaultEncoding" value="UTF-8"/>
</bean>
```


- src/main/resource/message 폴더 아래 생성
> message.properties
```
test = 메세지 리소스 테스트
```

> 컨트롤러
```java
@Controller 
public class HomeController {
	
	@RequestMapping("/")
	public String home(){
		return "index";
	}	
}
```

> index.jsp
```jsp
<!-- spring:message 커스텀 태그를 사용하기 위한 라이브러리 설정 추가  -->
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
<!-- ... -->

<h2>메세지리소스 테스트</h2> 
<h2>메세지리소스 테스트</h2> 
<spring:message code="test"/>
<spring:message code="member.username"/>  
<spring:message code="member.welcome"/><br>

<!-- 
    code 속성값에 공백문자가 있으면 예외가 발생한다. 
    다음과 같이 양끝에 공백문자가 있으면 예외가 발생한다.
    <spring:message code=" member.username"/>  
    <spring:message code="member.username "/>  
-->

```

<br><br>

### 회원가입 페이지 및 컨트롤러 

> 커맨드 객체 : MemberVo 
```java
public class MemberVo {
	private String username; 
	private String email; 
	private String password; 
	private String confirmPassword;
    // 게터세터 투스트링
}
```

<br>

> register.jsp
```jsp
<h2>회원가입</h2>

<form action="${pageContext.request.contextPath}/register" method="post">
<div>
	이름 : <input type="text" name="username">
</div>
<div>
	이메일 : <input type="text" name="email">
</div>
<div>
	비밀번호 : <input type="password" name="password">
</div>
<div>
	비밀번호 확인 <input type="password" name="passwordConfirm">
</div>
<div>
	<button>확인</button>
</div>
</form>
```

<br>

> 컨트롤러
```java
// 회원가입 폼으로 이동
@RequestMapping(value="/register", method=RequestMethod.GET)
public String registerForm() {
    return "register";
}

// 회원강비 처리 
@RequestMapping(value = "/register", method=RequestMethod.POST)
public String register(MemberVo vo){
    return "result";
}
```

<br>

> 결과페이지 : result.jsp
``` jsp
OK <br>
${memberVo.username} <br>
${memberVo.email} <br>
${memberVo.password} <br>
${memberVo.confirmPassword} <br>
```

<br><br>

### Validator 인터페이스 구현 

> Validator 인터페이스 
```java
package com.spring;

import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

public class MemberValidator implements Validator{

	@Override
	public boolean supports(Class<?> clazz) {
		// Validator가 해당 타입의 객체를 지원하는지 여부를 리턴한다.
		// MemberVoValidator클래스가 MemberVo 타입의 객체를 지원하도록 했다.
		return MemberVo.class.isAssignableFrom(clazz);
	}

	// @param1 : 값을 검증할 객체 여기서는 MemberVo 
	// @parma2 : 값이 올바르지 않을 경우 그 내용을 저장한다.
	@Override
	public void validate(Object target, Errors errors) {
		MemberVo vo = (MemberVo) target; // 검사대상 객체 형변환 
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "username", "required");
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "required");
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "required");
	}

}

```

> 컨트롤러
```java
@RequestMapping(value = "/register", method=RequestMethod.POST)
public String register(MemberVo vo, BindingResult bidingResult){
    // Errors파라미터나 BindingResult파라미터는 반드시 커맨드 객체 파라미터 바로 뒤에 와야한다.
    MemberValidator validator = new MemberValidator(); 
    validator.validate(vo, bidingResult);
    if(bidingResult.hasErrors()) {
        // null 검사를 하지 않으면 필드 값을 입력했을 때 예외가 발생한다.
        if(bidingResult.getFieldError("username") != null) 
				System.out.println("이름필드 : " + bidingResult.getFieldError("username").getCode());
        if(bidingResult.getFieldError("email") != null)
            System.out.println("이메일필드 : " + bidingResult.getFieldError("email").getCode());
        if(bidingResult.getFieldError("password") != null)
            System.out.println("비밀번호필드 : " + bidingResult.getFieldError("password").getCode());
    }
    return "result";
}
```
- 필드 값을 적지않거나 공백문자로 전송하여 테스트 해보자.

### 필드값에 에러가 있는경우 뷰페이지에 나타내기

<br>

> error.properties
```
required.username = 이름을 입력하세요
required.email = 이메일을 입력하세요
required.password = 비밀번호를 입력하세요
```

<br>

> root-context.xml
```xml
<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
	<property name="basenames">
		<list>
			<value>message.message</value>
			<value>message.erorr</value> <!-- 에러 메세지 설정 파일 추가 -->
		</list>
	</property>
	<property name="defaultEncoding" value="UTF-8"/>
</bean>
```

<br>

> register.jsp
```jsp
<form:form modelAttribute="memberVo" action="${pageContext.request.contextPath}/register" method="post">
<div>
	이름 : <form:input type="text" path="username"/>
    <form:errors path="username" class="error"/>
</div>
<div>
	이메일 : <form:input type="text" path="email"/>
    <form:errors path="email" class="error"/>
</div>
<div>
	비밀번호 : <form:input type="password" path="password"/>
    <form:errors path="password" class="error"/>
</div>
<div>
	비밀번호 확인 <form:input type="password" path="confirmPassword" class="error"/>
</div>
<div>
	<button>확인</button>
</div>
</form:form>
```
- modelAttribute 속성에 폼에서 사용할 커맨드 객체를 입력했다
- 컨트롤러에서 GET방식의 /register 요청을 할때 커맨드 객체를 지정하지 않으면 다음과 같은 오류메세지를 출력한다.
-  Neither BindingResult nor plain target object for bean name 'memberVo' available as request attribute
- path 속성에 세터메서드와 일차하지 않은 값이 오면 다음의 오류를 출력한다.
- Invalid property 'xxxxxxxxx' of bean class [com.spring.MemberVo]: Bean property 'xxxxxxxxx' is not readable or has an invalid getter method: Does the return type of the getter match the parameter type of the setter?

> 컨트롤러
```java
@RequestMapping(value="/register", method=RequestMethod.GET)
public String registerForm(MemberVo vo) {
    // 파라미터에 커맨드 객체 MemberVo를 추가한다.
    return "register";
}

@RequestMapping(value = "/register", method=RequestMethod.POST)
public String register(MemberVo vo, BindingResult bidingResult){
    MemberValidator validator = new MemberValidator(); 
    validator.validate(vo, bidingResult);
    if(bidingResult.hasErrors()) {
        if(bidingResult.hasErrors()) {
            // null검사를 하지 않으면 예외가 발생한다.
			if(bidingResult.getFieldError("username") != null) 
				System.out.println("이름필드 : " + bidingResult.getFieldError("username").getCode());
			if(bidingResult.getFieldError("email") != null)
				System.out.println("이메일필드 : " + bidingResult.getFieldError("email").getCode());
			if(bidingResult.getFieldError("password") != null)
				System.out.println("비밀번호필드 : " + bidingResult.getFieldError("password").getCode());
			return "register";
		}

        // 오류가 있는 경우에 폼 페이지로 다시 이동해야한다.
        return "register";
    }
    return "result";
}
```
- 비어 있는 필드 값을 전송하여 테스트 해보자.

### Validator 인터페이스에 나머지 요구사항 반영하기 

<br>

- username 필드 요구사항 
    + 한글만 허용
    + 최소2글 ~ 최대4글자까지

<br>

> common 패키지에 RegEx 클래스 생성
```java
public class RegEx {	
    // 한글만 허용하는 정규표현식
	public final static String ONLY_HANGUL = "^[가-힣]*$";
}
```

> Validator
```java
// 폼 필드에 값이 입력되었을 때 true를 리턴한다.
private boolean hasAttribute(String attribute) {
    return attribute != null && !attribute.trim().isEmpty();  
}

@Override
public void validate(Object target, Errors errors) {
    MemberVo vo = (MemberVo) target; // 검사대상 객체 형변환 
    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "username", "required");

    // checkUsername : username 필드에 나머지 유효성 검사한다.
    if(hasAttribute(vo.getUsername())) checkUsername(vo.getUsername(), errors);
            
    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "required");
    ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "required");
}

// 나머지 요구사항을 반영한다. 
private void checkUsername(String username, Errors errors) {
    // 한글로만 구성되어있는지 여부
    if(!Pattern.matches(RegEx.ONLY_HANGUL, username)) {
        errors.rejectValue("username", "notHangul");
        return;
    }
    // 최소길이
    if(username.length() < 2) {
        errors.rejectValue("username", "short");
        return; 
    }
    // 최대 길이 
    if(username.length() > 4) {
        errors.rejectValue("username", "long");
        return; 
    }	
}
```

<br>

- 비밀번호 요구사항 
    + 영어,숫자,특수문자 조합
    + 최소 8글자 이상
    + 최대 16글자 이하
    + 비밀번호 일치 여부확인

<br>

> RegEx
```java
public final static String PASSWORD_PATTERN = "^.*(?=^.*$)(?=.*\\d)(?=.*[a-zA-Z])(?=.*[!@#$%^&+=]).*$";
```

<br>

> Validator 인터페이스
```java
// 비밀번호 유효성 검사 
ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "required");
	if(hasAttribute(vo.getPassword())) 
        checkPassword(vo.getPassword(), vo.getConfirmPassword() ,errors);

/* ... */
private void checkPassword(String password,String confirmPassword,Errors errors) {
    if(!Pattern.matches(RegEx.PASSWORD_PATTERN, password)) {
        errors.rejectValue("password", "incorrectPatter");
        return;
    }
    if(password.length() < 8) {
        errors.rejectValue("password", "short");
        return; 
    }
    if(password.length() > 16) {
        errors.rejectValue("password", "long");
        return; 
    }	
    if(!password.equals(confirmPassword)) {
        errors.rejectValue("password", "notSame");
    }
}
```

<br>

> error.properties
```
required.password = 비밀번호를 입력하세요
incorrectPatter.password = 비밀번호는 영어,특수문자,숫자 조합으로 구성됩니다.
short.password = 비밀번호는 최소 8자 이상이어야합니다.
long.password = 비밀번호는 최대 16자까지 가능합니다. 
notSame.password = 비밀번호가 일치하지 않습니다.
```

<br><br>

- 이메일 검사
    + 이메일 형식 검사
    + 이메일 중복여부 

<br>

> common RegEx
```java
public final static String EMAIL_PATTERN = "^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$";
```

<br>

> error.properties
```
required.email = 이메일을 입력하세요
incorrect.email = 이메일 형식이 아닙니다.
duplicate.email = 중복된 이메일입니다.
```

<br>

> Validator
```java
ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "required");
if(hasAttribute(vo.getEmail())) checkEmail(vo.getEmail(),errors);

/* ... */
private void checkEmail(String email, Errors errors) {
    if(!Pattern.matches(RegEx.EMAIL_PATTERN, email)) {
        errors.rejectValue("email", "incorrect");
        return; 
    }
}
```

<br>

- 이제 이메일 중복여부를 검사해보자.
- 데이터베이스를 사용하지않고 이미 가입한 회원이 1명이라고 가정한다.
```java
@Repository
public class MemberDao {
    
    // 이미 가입된 회원의 메일이 다음과 같다고 가정한다.
	public MemberVo findByEmail(String email) {
		MemberVo vo = null; 
		if(email.equals("lee@naver.com")) {
			vo = new MemberVo();
			vo.setEmail(email);
		}
		return vo;
	}
}
```

- 컨트롤러에서 MemberDao 객체를 주입받아야한다.
```java
@Controller 
public class HomeController {
	
	private MemberDao memberDao; 
	
	@Autowired
	public HomeController(MemberDao memberDao) {
		this.memberDao = memberDao;
	}
    /* ... */

@RequestMapping(value = "/register", method=RequestMethod.POST)
	public String register(MemberVo vo, BindingResult bidingResult){
		
        // validator에서 email로 회원을 조회하여야한다.
        // validator생성시 memberDao를 주입한다.
		MemberValidator validator = new MemberValidator();
		validator.setMemberDao(memberDao);
		/* ... */
		return "result";
	}
}
```


> Validaotr
```java
public class MemberValidator implements Validator{
	
	
    private MemberDao memberDao;

    public void setMemberDao(MemberDao memberDao) {
        this.memberDao = memberDao;
    }

    /* ... */

    private void checkEmail(String email, Errors errors) {
		if(!Pattern.matches(RegEx.EMAIL_PATTERN, email)) {
			errors.rejectValue("email", "incorrect");
			return; 
		}
		
        // 전달된 email 가입된 회원이 존재한다면 에러 메세지를 추가한다.
		if(memberDao.findByEmail(email) != null) {
			errors.rejectValue("email", "duplicate");
			return;
		}
	}

    /* .... */
}
```

<br>

## 전체코드

> 도메인
```java
package com.spring;

public class MemberVo {
	private String username; 
	private String email; 
	private String password; 
	private String confirmPassword;
	
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getPassword() {
		return password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getConfirmPassword() {
		return confirmPassword;
	}
	public void setConfirmPassword(String confirmPassword) {
		this.confirmPassword = confirmPassword;
	}
	@Override
	public String toString() {
		return "MemberVo [username=" + username + ", email=" + email + ", password=" + password + ", confirmPassword="
				+ confirmPassword + "]";
	}
}

```


> 컨틀롤러
```java
package com.spring;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import com.spring.dao.MemberDao;

@Controller 
public class HomeController {
	
	private MemberDao memberDao; 
	
	@Autowired
	public HomeController(MemberDao memberDao) {
		this.memberDao = memberDao;
	}

	@RequestMapping("/")
	public String home(){
		return "index";
	}
	
	@RequestMapping(value="/register", method=RequestMethod.GET)
	public String registerForm(MemberVo vo) {
		return "register";
	}
	
	@RequestMapping(value = "/register", method=RequestMethod.POST)
	public String register(MemberVo vo, BindingResult bidingResult){
		// Errors파라미터나 BindingResult파라미터는 반드시 커맨드 객체 파라미터 바로 뒤에 와야한다.
		MemberValidator validator = new MemberValidator();
		validator.setMemberDao(memberDao);
		validator.validate(vo, bidingResult);
		if(bidingResult.hasErrors()) {
			if(bidingResult.getFieldError("username") != null) 
				System.out.println("이름필드 : " + bidingResult.getFieldError("username").getCode());
			if(bidingResult.getFieldError("email") != null)
				System.out.println("이메일필드 : " + bidingResult.getFieldError("email").getCode());
			if(bidingResult.getFieldError("password") != null)
				System.out.println("비밀번호필드 : " + bidingResult.getFieldError("password").getCode());
			return "register";
		}
		return "result";
	}
}
```

<br>

> 모델
```java
package com.spring.dao;

import org.springframework.stereotype.Repository;

import com.spring.MemberVo;

@Repository
public class MemberDao {
	
	public MemberVo findByEmail(String email) {
		MemberVo vo = null; 
		if(email.equals("lee@naver.com")) {
			vo = new MemberVo();
			vo.setEmail(email);
		}
		return vo;
	}
}

```

> Validator
```java
package com.spring;

import java.util.regex.Pattern;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.Errors;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;

import com.spring.common.RegEx;
import com.spring.dao.MemberDao;

public class MemberValidator implements Validator{
	
	
	private MemberDao memberDao;
	
	public void setMemberDao(MemberDao memberDao) {
		this.memberDao = memberDao;
	}

	@Override
	public boolean supports(Class<?> clazz) {
		// Validator가 해당 타입의 객체를 지원하는지 여부를 리턴한다.
		// MemberVoValidator클래스가 MemberVo 타입의 객체를 지원하도록 했다.
		return MemberVo.class.isAssignableFrom(clazz);
	}

	// @param1 : 값을 검증할 객체 여기서는 MemberVo 
	// @parma2 : 값이 올바르지 않을 경우 그 내용을 저장한다.
	@Override
	public void validate(Object target, Errors errors) {
		MemberVo vo = (MemberVo) target; // 검사대상 객체 형변환 
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "username", "required");
		if(hasAttribute(vo.getUsername())) checkUsername(vo.getUsername(), errors);
		
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "password", "required");
		if(hasAttribute(vo.getPassword())) checkPassword(vo.getPassword(), vo.getConfirmPassword() ,errors);
		
		ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "required");
		if(hasAttribute(vo.getEmail())) checkEmail(vo.getEmail(),errors);
	}
	
	private void checkEmail(String email, Errors errors) {
		if(!Pattern.matches(RegEx.EMAIL_PATTERN, email)) {
			errors.rejectValue("email", "incorrect");
			return; 
		}
		
		if(memberDao.findByEmail(email) != null) {
			errors.rejectValue("email", "duplicate");
			return;
		}
	}

	private void checkPassword(String password,String confirmPassword,Errors errors) {
		if(!Pattern.matches(RegEx.PASSWORD_PATTERN, password)) {
			errors.rejectValue("password", "incorrectPatter");
			return;
		}
		if(password.length() < 8) {
			errors.rejectValue("password", "short");
			return; 
		}
		if(password.length() > 16) {
			errors.rejectValue("password", "long");
			return; 
		}	
		if(!password.equals(confirmPassword)) {
			errors.rejectValue("password", "notSame");
		}
	}

	private void checkUsername(String username, Errors errors) {
		if(!Pattern.matches(RegEx.ONLY_HANGUL, username)) {
			errors.rejectValue("username", "notHangul");
			return;
		}
		if(username.length() < 2) {
			errors.rejectValue("username", "short");
			return; 
		}
		if(username.length() > 4) {
			errors.rejectValue("username", "long");
			return; 
		}	
	}

	private boolean hasAttribute(String attribute) {
		return attribute != null && !attribute.trim().isEmpty();  
	}

}
```

<br>

> 정규표현식
```java
package com.spring.common;

public class RegEx {
	
	public final static String ONLY_HANGUL = "^[가-힣]*$";
	public final static String PASSWORD_PATTERN = "^.*(?=^.*$)(?=.*\\d)(?=.*[a-zA-Z])(?=.*[!@#$%^&+=]).*$";
	public final static String EMAIL_PATTERN = "^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*.[a-zA-Z]{2,3}$";
}
```

<br>

> 메세지 리소스 설정
```xml
<bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
	<property name="basenames">
		<list>
			<value>message.message</value>
			<value>message.error</value>
		</list>
	</property>
	<property name="defaultEncoding" value="UTF-8"/>
</bean>	
```

<br>

> 에러메세지 : errors.properties
```
required.username = 이름을 입력하세요
notHangul.username = 이름은 한글로 입력해야 합니다.
short.username = 이름은 최소 2글자를 입력하세요
long.username = 이름은 최대 4글자까지 가능합니다.



required.password = 비밀번호를 입력하세요
incorrectPatter.password = 비밀번호는 영어,특수문자,숫자 조합으로 구성됩니다.
short.password = 비밀번호는 최소 8자 이상이어야합니다.
long.password = 비밀번호는 최대 16자까지 가능합니다. 
notSame.password = 비밀번호가 일치하지 않습니다.

required.email = 이메일을 입력하세요
incorrect.email = 이메일 형식이 아닙니다.
duplicate.email = 중복된 이메일입니다.
```

<br>

> 메세지 리소스 : messages.properties
```
test = 메세지 리소스 테스트
member.username = 이광협
member.welcome = 환영합니다
```

<br>

>index
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="${pageContext.request.contextPath}/resources/css/style.css"/>
<title>Insert title here</title>
</head>
<body>
<h2>메세지리소스 테스트</h2> 
<spring:message code="test"/>
<spring:message code="member.username"/>  
<spring:message code="member.welcome"/><br>

<a href="${pageContext.request.contextPath}/register">회원가입</a>

</html>

```

<br>

>register
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<h2>회원가입</h2>

<form:form modelAttribute="memberVo" action="${pageContext.request.contextPath}/register" method="post">
<div>
	이름 : <form:input type="text" path="username"/>
	<form:errors path="username" class="error" />
</div>
<div>
	이메일 : <form:input type="text" path="email"/>
	<form:errors path="email" class="error"/>
</div>
<div>
	비밀번호 : <form:input type="password"  path="password"/>
	<form:errors path="password" class="error"/>
</div>
<div>
	비밀번호 확인 <form:input type="password" path="confirmPassword" />
</div>
<div>
	<button>확인</button>
</div>
</form:form>

</body>
<style>
.error {font-size:12px; color:red;}
</style>
</html>
```

<br>

>result
```jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
OK <br>
${memberVo.username} <br>
${memberVo.email} <br>
${memberVo.password} <br>
${memberVo.confirmPassword} <br>

</body>
</html>
```

<br>

